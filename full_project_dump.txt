--- FILE: ./src/lib.rs ---
pub mod vm;
pub mod compiler;
pub mod events;
pub use vm::{Op, VM, VMError};
pub use compiler::{parse_dsl, CompilerError};
pub use events::{Event, LogFormat, set_log_format, set_log_file}; --- FILE: ./src/main.rs ---
mod vm;
mod compiler;
mod events;
use std::fs;
use std::path::Path;
use vm::{Op, VM, VMError};
use compiler::{parse_dsl, CompilerError};
use events::Event;
use clap::{Arg, Command};
use serde_json;
use std::process;
use std::error::Error;
use thiserror::Error;
use std::collections::HashMap;

#[derive(Debug, Error)]
enum AppError {
    #[error("VM error: {0}")]
    VM(#[from] VMError),

    #[error("Compiler error: {0}")]
    Compiler(#[from] CompilerError),

    #[error("IO error: {0}")]
    IO(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("{0}")]
    Other(String),
}

impl From<&str> for AppError {
    fn from(s: &str) -> Self {
        AppError::Other(s.to_string())
    }
}

impl From<String> for AppError {
    fn from(s: String) -> Self {
        AppError::Other(s)
    }
}

fn main() {
    // Parse command line arguments
    let matches = Command::new("nano-cvm")
        .version("0.2.0")
        .author("Intercooperative Network")
        .about("Secure stack-based virtual machine with governance-inspired opcodes")
        .arg(Arg::new("program")
            .short('p')
            .long("program")
            .value_name("FILE")
            .help("Program file to execute (.dsl or .json)")
            .default_value("program.dsl"))
        .arg(Arg::new("verbose")
            .short('v')
            .long("verbose")
            .help("Display detailed execution information")
            .action(clap::ArgAction::SetTrue))
        .arg(Arg::new("param")
            .short('P')
            .long("param")
            .value_name("KEY=VALUE")
            .help("Set a key-value parameter for the program (can be used multiple times)")
            .action(clap::ArgAction::Append))
        .arg(Arg::new("interactive")
            .short('i')
            .long("interactive")
            .help("Start in interactive REPL mode")
            .action(clap::ArgAction::SetTrue))
        .get_matches();

    // Get program file and verbosity setting
    let program_path = matches.get_one::<String>("program").unwrap();
    let verbose = matches.get_flag("verbose");
    let interactive = matches.get_flag("interactive");
    
    // Collect parameters
    let mut parameters = HashMap::new();
    if let Some(params) = matches.get_many::<String>("param") {
        for param_str in params {
            if let Some(equals_pos) = param_str.find('=') {
                let key = param_str[0..equals_pos].to_string();
                let value = param_str[equals_pos+1..].to_string();
                if verbose {
                    println!("Parameter: {} = {}", key, value);
                }
                parameters.insert(key, value);
            } else {
                eprintln!("Warning: Invalid parameter format '{}', expected KEY=VALUE", param_str);
            }
        }
    }

    // Execute the program
    if interactive {
        if let Err(err) = run_interactive(verbose, parameters) {
            eprintln!("Error: {}", err);
            process::exit(1);
        }
    } else {
        if let Err(err) = run_program(program_path, verbose, parameters) {
            eprintln!("Error: {}", err);
            process::exit(1);
        }
    }
}

fn run_program(program_path: &str, verbose: bool, parameters: HashMap<String, String>) -> Result<(), AppError> {
    let path = Path::new(program_path);
    
    // Check if file exists
    if !path.exists() {
        return Err(format!("Program file not found: {}", program_path).into());
    }
    
    // Parse operations based on file extension
    let ops = if let Some(extension) = path.extension().and_then(|e| e.to_str()) {
        match extension.to_lowercase().as_str() {
            "dsl" => {
                if verbose {
                    println!("Parsing DSL program from {}", program_path);
                }
                let program_source = fs::read_to_string(path)?;
                parse_dsl(&program_source)?
            },
            "json" => {
                if verbose {
                    println!("Parsing JSON program from {}", program_path);
                }
                let program_json = fs::read_to_string(path)?;
                serde_json::from_str(&program_json)?
            },
            _ => return Err(format!("Unsupported file extension: {}", extension).into())
        }
    } else {
        return Err("File has no extension".into());
    };
    
    if verbose {
        println!("Program loaded with {} operations", ops.len());
    }

    // Create and execute the VM
    let mut vm = VM::new();
    
    // Set parameters
    vm.set_parameters(parameters)?;
    
    if verbose {
        println!("Executing program...");
        println!("-----------------------------------");
    }
    
    vm.execute(&ops)?;
    
    if verbose {
        println!("-----------------------------------");
        println!("Program execution completed successfully");
    }

    // Print the final stack
    println!("Final stack:");
    for (i, &value) in vm.get_stack().iter().enumerate() {
        println!("  {}: {}", i, value);
    }

    Ok(())
}

fn run_interactive(verbose: bool, parameters: HashMap<String, String>) -> Result<(), AppError> {
    use std::io::{self, Write, BufRead};
    
    println!("nano-cvm interactive mode");
    println!("Enter commands in DSL format, 'help' for available commands, 'exit' to quit");
    
    let mut vm = VM::new();
    vm.set_parameters(parameters)?;
    
    // Show initial parameters if any
    if !vm.get_memory_map().is_empty() {
        println!("Initial parameters:");
        for (key, &value) in vm.get_memory_map().iter() {
            println!("  {}: {}", key, value);
        }
    }
    
    let stdin = io::stdin();
    let mut handle = stdin.lock();
    let mut buffer = String::new();
    
    loop {
        print!("> ");
        io::stdout().flush()?;
        
        buffer.clear();
        handle.read_line(&mut buffer)?;
        
        let input = buffer.trim();
        
        match input {
            "exit" | "quit" => {
                println!("Exiting interactive mode");
                break;
            },
            "help" => {
                println!("Available commands:");
                println!("  push <number>     - Push a number onto the stack");
                println!("  add               - Add the top two values on the stack");
                println!("  sub               - Subtract the top value from the second value");
                println!("  mul               - Multiply the top two values on the stack");
                println!("  div               - Divide the second value by the top value");
                println!("  dup               - Duplicate the top value on the stack");
                println!("  swap              - Swap the top two values on the stack");
                println!("  emit \"message\"    - Output a message");
                println!("  store <key>       - Store the top stack value in memory with the given key");
                println!("  load <key>        - Load a value from memory with the given key");
                println!("  dump_stack        - Display the current stack");
                println!("  dump_memory       - Display the current memory");
                println!("  exit, quit        - Exit the interactive mode");
            },
            "dump_stack" => {
                println!("Stack:");
                for (i, &value) in vm.get_stack().iter().enumerate() {
                    println!("  {}: {}", i, value);
                }
            },
            "dump_memory" => {
                println!("Memory:");
                for (key, &value) in vm.get_memory_map().iter() {
                    println!("  {}: {}", key, value);
                }
            },
            _ => {
                // Try to parse and execute the input as DSL
                if !input.is_empty() {
                    match parse_dsl(input) {
                        Ok(ops) => {
                            if verbose {
                                println!("Executing {} operation(s)", ops.len());
                            }
                            
                            if let Err(err) = vm.execute(&ops) {
                                println!("Error executing operations: {}", err);
                            } else if verbose {
                                println!("Operation(s) executed successfully");
                                
                                println!("Stack:");
                                for (i, &value) in vm.get_stack().iter().enumerate() {
                                    println!("  {}: {}", i, value);
                                }
                            }
                        },
                        Err(err) => {
                            println!("Error parsing input: {}", err);
                        }
                    }
                }
            }
        }
    }
    
    Ok(())
}
--- FILE: ./src/events.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::fs::{File, OpenOptions};
use std::io::{self, Write};
use std::path::Path;
use std::sync::Mutex;
use once_cell::sync::Lazy;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub level: String,     // "info", "warn", "error"
    pub tag: String,       // e.g., "emit", "stack", "memory", "governance"
    pub message: String,
    pub timestamp: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogFormat {
    Pretty,
    Json,
}

static LOG_FORMAT: Lazy<Mutex<LogFormat>> = Lazy::new(|| Mutex::new(LogFormat::Pretty));
static LOG_FILE: Lazy<Mutex<Option<String>>> = Lazy::new(|| Mutex::new(None));

impl Event {
    pub fn new<S1: Into<String>, S2: Into<String>, S3: Into<String>>(level: S1, tag: S2, message: S3) -> Self {
        let now: DateTime<Utc> = Utc::now();
        
        Self {
            level: level.into(),
            tag: tag.into(),
            message: message.into(),
            timestamp: now.to_rfc3339(),
            data: None,
        }
    }
    
    pub fn with_data(mut self, data: serde_json::Value) -> Self {
        self.data = Some(data);
        self
    }
    
    pub fn info<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
        Self::new("info", tag, message)
    }
    
    pub fn warn<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
        Self::new("warn", tag, message)
    }
    
    pub fn error<S1: Into<String>, S2: Into<String>>(tag: S1, message: S2) -> Self {
        Self::new("error", tag, message)
    }
    
    pub fn emit(&self) -> io::Result<()> {
        let format = LOG_FORMAT.lock().unwrap();
        let log_file = LOG_FILE.lock().unwrap().clone();
        
        match *format {
            LogFormat::Pretty => self.emit_pretty(log_file),
            LogFormat::Json => self.emit_json(log_file),
        }
    }
    
    fn emit_pretty(&self, log_file: Option<String>) -> io::Result<()> {
        let level_color = match self.level.as_str() {
            "info" => "\x1b[32m", // Green
            "warn" => "\x1b[33m", // Yellow
            "error" => "\x1b[31m", // Red
            _ => "\x1b[0m",       // Default
        };
        
        let pretty_line = format!(
            "{}{} [{}] [{}] {}\x1b[0m", 
            level_color,
            self.timestamp.split('T').nth(1).unwrap_or(&self.timestamp).split('.').next().unwrap_or(""),
            self.level.to_uppercase(), 
            self.tag,
            self.message
        );
        
        // Always print to stdout
        println!("{}", pretty_line);
        
        // If log file is specified, write to it
        if let Some(file_path) = log_file {
            let plain_line = format!(
                "{} [{}] [{}] {}", 
                self.timestamp, 
                self.level.to_uppercase(), 
                self.tag,
                self.message
            );
            
            append_to_file(&file_path, &plain_line)?;
        }
        
        Ok(())
    }
    
    fn emit_json(&self, log_file: Option<String>) -> io::Result<()> {
        let json = serde_json::to_string(&self).unwrap();
        
        // Always print to stdout
        println!("{}", json);
        
        // If log file is specified, write to it
        if let Some(file_path) = log_file {
            append_to_file(&file_path, &json)?;
        }
        
        Ok(())
    }
}

pub fn set_log_format(format: LogFormat) {
    let mut log_format = LOG_FORMAT.lock().unwrap();
    *log_format = format;
}

pub fn set_log_file(file_path: Option<String>) {
    let mut log_file = LOG_FILE.lock().unwrap();
    *log_file = file_path;
}

fn append_to_file(file_path: &str, content: &str) -> io::Result<()> {
    let path = Path::new(file_path);
    
    // Create parent directories if they don't exist
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent)?;
        }
    }
    
    // Open file with append mode
    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(path)?;
    
    // Write content with newline
    writeln!(file, "{}", content)?;
    
    Ok(())
} --- FILE: ./src/vm.rs ---
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use thiserror::Error;
use crate::events::Event;

#[derive(Debug, Error, Clone, PartialEq)]
pub enum VMError {
    #[error("Stack underflow in {op}: needed {needed}, found {found}")]
    StackUnderflow { op: String, needed: usize, found: usize },
    
    #[error("Division by zero")]
    DivisionByZero,
    
    #[error("Variable not found: {0}")]
    VariableNotFound(String),
    
    #[error("Function not found: {0}")]
    FunctionNotFound(String),
    
    #[error("Maximum recursion depth exceeded")]
    MaxRecursionDepth,
    
    #[error("Invalid condition: {0}")]
    InvalidCondition(String),
    
    #[error("Assertion failed: expected {expected}, found {found}")]
    AssertionFailed { expected: f64, found: f64 },
    
    #[error("IO error: {0}")]
    IOError(String),
    
    #[error("REPL error: {0}")]
    ReplError(String),
    
    #[error("Parameter error: {0}")]
    ParameterError(String),
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum Op {
    Push(f64),
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Store(String),
    Load(String),
    If { condition: Vec<Op>, then: Vec<Op>, else_: Option<Vec<Op>> },
    Loop { count: usize, body: Vec<Op> },
    While { condition: Vec<Op>, body: Vec<Op> },
    Emit(String),
    Negate,
    AssertTop(f64),
    DumpStack,
    DumpMemory,
    AssertMemory { key: String, expected: f64 },
    Pop,
    Eq,
    Gt,
    Lt,
    Not,
    And,
    Or,
    Dup,
    Swap,
    Over,
    Def { name: String, params: Vec<String>, body: Vec<Op> },
    Call(String),
    Return,
    Nop,
    // New governance-inspired opcodes
    Match { value: Vec<Op>, cases: Vec<(f64, Vec<Op>)>, default: Option<Vec<Op>> },
    Break,
    Continue,
    EmitEvent { category: String, message: String },
    AssertEqualStack { depth: usize },
}

#[derive(Debug)]
struct CallFrame {
    memory: HashMap<String, f64>,
    return_value: Option<f64>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum LoopControl {
    None,
    Break,
    Continue,
}

#[derive(Debug)]
pub struct VM {
    pub stack: Vec<f64>,
    memory: HashMap<String, f64>,
    functions: HashMap<String, (Vec<String>, Vec<Op>)>,
    call_frames: Vec<CallFrame>,
    recursion_depth: usize,
    loop_control: LoopControl,
}

impl VM {
    pub fn new() -> Self {
        VM {
            stack: Vec::new(),
            memory: HashMap::new(),
            functions: HashMap::new(),
            call_frames: Vec::new(),
            recursion_depth: 0,
            loop_control: LoopControl::None,
        }
    }

    pub fn get_stack(&self) -> &[f64] {
        &self.stack
    }

    pub fn get_memory(&self, key: &str) -> Option<f64> {
        self.memory.get(key).copied()
    }

    pub fn get_memory_map(&self) -> &HashMap<String, f64> {
        &self.memory
    }

    pub fn set_parameters(&mut self, params: HashMap<String, String>) -> Result<(), VMError> {
        for (key, value) in params {
            // Try to parse as f64 first
            match value.parse::<f64>() {
                Ok(num) => {
                    self.memory.insert(key.clone(), num);
                }
                Err(_) => {
                    // For non-numeric strings, we'll store the length as a numeric value
                    // This allows parameters to be used in the stack machine
                    self.memory.insert(key.clone(), value.len() as f64);
                    
                    // Also log this for debugging
                    let event = Event::info(
                        "params", 
                        &format!("Parameter '{}' is not numeric, storing length {}", key, value.len())
                    );
                    event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                }
            }
        }
        Ok(())
    }

    pub fn execute(&mut self, ops: &[Op]) -> Result<(), VMError> {
        if self.recursion_depth > 1000 {
            return Err(VMError::MaxRecursionDepth);
        }
        self.execute_inner(ops)
    }

    // Helper for stack operations that need to pop one value
    fn pop_one(&mut self, op_name: &str) -> Result<f64, VMError> {
        self.stack.pop().ok_or_else(|| VMError::StackUnderflow { 
            op: op_name.to_string(), 
            needed: 1, 
            found: 0 
        })
    }

    // Helper for stack operations that need to pop two values
    fn pop_two(&mut self, op_name: &str) -> Result<(f64, f64), VMError> {
        if self.stack.len() < 2 {
            return Err(VMError::StackUnderflow { 
                op: op_name.to_string(), 
                needed: 2, 
                found: self.stack.len() 
            });
        }
        let b = self.stack.pop().unwrap();
        let a = self.stack.pop().unwrap();
        Ok((a, b))
    }

    fn execute_inner(&mut self, ops: &[Op]) -> Result<(), VMError> {
        if self.recursion_depth > 1000 {
            return Err(VMError::MaxRecursionDepth);
        }

        let mut pc = 0;
        while pc < ops.len() {
            // Check for loop control flow
            if self.loop_control != LoopControl::None {
                break;
            }
            
            let op = &ops[pc];
            match op {
                Op::Push(value) => {
                    self.stack.push(*value);
                }
                Op::Pop => {
                    self.pop_one("Pop")?;
                }
                Op::Dup => {
                    let value = self.stack.last().ok_or_else(|| VMError::StackUnderflow { 
                        op: "Dup".to_string(), 
                        needed: 1, 
                        found: 0 
                    })?;
                    self.stack.push(*value);
                }
                Op::Swap => {
                    if self.stack.len() < 2 {
                        return Err(VMError::StackUnderflow { 
                            op: "Swap".to_string(), 
                            needed: 2, 
                            found: self.stack.len()
                        });
                    }
                    let len = self.stack.len();
                    self.stack.swap(len - 1, len - 2);
                }
                Op::Over => {
                    if self.stack.len() < 2 {
                        return Err(VMError::StackUnderflow { 
                            op: "Over".to_string(), 
                            needed: 2, 
                            found: self.stack.len()
                        });
                    }
                    let value = self.stack[self.stack.len() - 2];
                    self.stack.push(value);
                }
                Op::Emit(msg) => {
                    let event = Event::info("emit", msg);
                    event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                }
                Op::Add => {
                    let (a, b) = self.pop_two("Add")?;
                    self.stack.push(a + b);
                }
                Op::Sub => {
                    let (a, b) = self.pop_two("Sub")?;
                    self.stack.push(a - b);
                }
                Op::Mul => {
                    let (a, b) = self.pop_two("Mul")?;
                    self.stack.push(a * b);
                }
                Op::Div => {
                    let (a, b) = self.pop_two("Div")?;
                    if b == 0.0 {
                        return Err(VMError::DivisionByZero);
                    }
                    self.stack.push(a / b);
                }
                Op::Mod => {
                    let (a, b) = self.pop_two("Mod")?;
                    if b == 0.0 {
                        return Err(VMError::DivisionByZero);
                    }
                    self.stack.push(a % b);
                }
                Op::Eq => {
                    let (a, b) = self.pop_two("Eq")?;
                    self.stack.push(if (a - b).abs() < f64::EPSILON { 0.0 } else { 1.0 });
                }
                Op::Lt => {
                    let (a, b) = self.pop_two("Lt")?;
                    self.stack.push(if a < b { 0.0 } else { 1.0 });
                }
                Op::Gt => {
                    let (a, b) = self.pop_two("Gt")?;
                    self.stack.push(if a > b { 0.0 } else { 1.0 });
                }
                Op::Not => {
                    let value = self.pop_one("Not")?;
                    self.stack.push(if value == 0.0 { 1.0 } else { 0.0 });
                }
                Op::And => {
                    let (a, b) = self.pop_two("And")?;
                    self.stack.push(if a != 0.0 && b != 0.0 { 1.0 } else { 0.0 });
                }
                Op::Or => {
                    let (a, b) = self.pop_two("Or")?;
                    self.stack.push(if a != 0.0 || b != 0.0 { 1.0 } else { 0.0 });
                }
                Op::Store(key) => {
                    let value = self.pop_one("Store")?;
                    
                    // We need to store in the current function's memory if we're in a function call
                    if !self.call_frames.is_empty() {
                        // Store in the current call frame
                        self.call_frames.last_mut().unwrap().memory.insert(key.clone(), value);
                    } else {
                        // Otherwise store in global memory
                        self.memory.insert(key.clone(), value);
                    }
                }
                Op::Load(key) => {
                    // First check the current function's memory if we're in a function
                    let value = if !self.call_frames.is_empty() {
                        // Check the current call frame first
                        if let Some(value) = self.call_frames.last().unwrap().memory.get(key) {
                            *value
                        } else {
                            // If not found in function memory, check global memory
                            *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
                        }
                    } else {
                        // If not in a function, just use global memory
                        *self.memory.get(key).ok_or_else(|| VMError::VariableNotFound(key.clone()))?
                    };
                    
                    self.stack.push(value);
                }
                Op::DumpStack => {
                    let stack_data = serde_json::to_value(&self.stack).unwrap_or(serde_json::Value::Null);
                    let event = Event::info("stack", "Dumping stack contents")
                        .with_data(stack_data);
                    event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                }
                Op::DumpMemory => {
                    let memory_data = serde_json::to_value(&self.memory).unwrap_or(serde_json::Value::Null);
                    let event = Event::info("memory", "Dumping memory contents")
                        .with_data(memory_data);
                    event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                }
                Op::Def { name, params, body } => {
                    self.functions.insert(name.clone(), (params.clone(), body.clone()));
                }
                
                Op::Loop { count, body } => {
                    for _i in 0..*count {
                        self.execute_inner(body)?;
                        
                        // Handle loop control flow
                        match self.loop_control {
                            LoopControl::Break => {
                                self.loop_control = LoopControl::None;
                                break;
                            },
                            LoopControl::Continue => {
                                self.loop_control = LoopControl::None;
                                continue;
                            },
                            LoopControl::None => {}
                        }
                    }
                }
                
                Op::While { condition, body } => {
                    if condition.is_empty() {
                        return Err(VMError::InvalidCondition(
                            "While condition block cannot be empty".to_string()
                        ));
                    }

                    loop {
                        // Execute the condition code
                        self.execute_inner(condition)?;
                        
                        // Get the result of the condition
                        let cond = self.pop_one("While condition")?;
                        
                        // If condition is true (0.0), execute the body
                        // If condition is false (non-zero), exit the loop
                        if cond != 0.0 {
                            break;
                        }
                        
                        // Execute the body code
                        self.execute_inner(body)?;
                        
                        // Handle loop control flow
                        match self.loop_control {
                            LoopControl::Break => {
                                self.loop_control = LoopControl::None;
                                break;
                            },
                            LoopControl::Continue => {
                                self.loop_control = LoopControl::None;
                                continue;
                            },
                            LoopControl::None => {}
                        }
                    }
                }
                
                Op::Break => {
                    self.loop_control = LoopControl::Break;
                }
                
                Op::Continue => {
                    self.loop_control = LoopControl::Continue;
                }
                
                Op::EmitEvent { category, message } => {
                    let event = Event::info(category.as_str(), message.as_str());
                    event.emit().map_err(|e| VMError::IOError(e.to_string()))?;
                }
                
                Op::AssertEqualStack { depth } => {
                    if self.stack.len() < *depth {
                        return Err(VMError::StackUnderflow {
                            op: "AssertEqualStack".to_string(),
                            needed: *depth,
                            found: self.stack.len(),
                        });
                    }
                    
                    let top_value = self.stack[self.stack.len() - 1];
                    for i in 1..*depth {
                        if (self.stack[self.stack.len() - 1 - i] - top_value).abs() >= f64::EPSILON {
                            return Err(VMError::AssertionFailed {
                                expected: top_value,
                                found: self.stack[self.stack.len() - 1 - i],
                            });
                        }
                    }
                }

                Op::If { condition, then, else_ } => {
                    // Get condition value 
                    let condition_value = if condition.is_empty() {
                        // If condition is empty, use the value already on the stack
                        if self.stack.is_empty() {
                            return Err(VMError::StackUnderflow { 
                                op: "If".to_string(), 
                                needed: 1, 
                                found: 0 
                            });
                        }
                        self.pop_one("If condition")?
                    } else {
                        // Save the stack size before executing the condition
                        let stack_size_before = self.stack.len();
                        
                        // Execute the condition operations
                        self.execute_inner(condition)?;
                        
                        // Make sure the stack has at least one more value than before
                        if self.stack.len() <= stack_size_before {
                            return Err(VMError::InvalidCondition(
                                "Condition block did not leave a value on the stack".to_string()
                            ));
                        }
                        
                        // Get the top value from the stack
                        self.pop_one("If condition result")?
                    };

                    // Execute the then block when condition is 0.0 (true)
                    // or the else block when condition is non-zero (false)
                    if condition_value == 0.0 {
                        self.execute_inner(then)?;
                    } else if let Some(else_block) = else_ {
                        self.execute_inner(else_block)?;
                    } else {
                        // If condition is non-zero (false) and no else block, preserve the condition value
                        self.stack.push(condition_value);
                    }
                }
                
                Op::Negate => {
                    let value = self.pop_one("Negate")?;
                    self.stack.push(-value);
                }
                
                Op::Call(name) => {
                    let (params, body) = self.functions.get(name)
                        .ok_or_else(|| VMError::FunctionNotFound(name.clone()))?
                        .clone();
                    
                    // Create a new call frame for function execution
                    let mut frame = CallFrame {
                        memory: HashMap::new(),
                        return_value: None,
                    };
                    
                    // If there are named parameters, pop values for them from the stack
                    if !params.is_empty() {
                        if self.stack.len() < params.len() {
                            return Err(VMError::StackUnderflow {
                                op: format!("Call to function '{}'", name),
                                needed: params.len(),
                                found: self.stack.len(),
                            });
                        }
                        
                        // Pop values from the stack in reverse order (last parameter first)
                        let mut param_values = Vec::with_capacity(params.len());
                        for _ in 0..params.len() {
                            param_values.push(self.stack.pop().unwrap());
                        }
                        param_values.reverse(); // Reverse to match parameter order
                        
                        // Store parameters in the function's memory
                        for (param, value) in params.iter().zip(param_values.iter()) {
                            frame.memory.insert(param.clone(), *value);
                        }
                    }
                    
                    // Push the call frame onto the call stack
                    self.call_frames.push(frame);
                    
                    // Increment recursion depth
                    self.recursion_depth += 1;
                    
                    // Execute the function body
                    self.execute_inner(&body)?;
                    
                    // Decrement recursion depth
                    self.recursion_depth -= 1;
                    
                    // Pop the call frame and get the return value if there is one
                    let frame = self.call_frames.pop().unwrap();
                    
                    // Push the return value onto the stack if there is one
                    if let Some(return_value) = frame.return_value {
                        self.stack.push(return_value);
                    }
                }
                
                Op::Return => {
                    // If we're in a function, set the return value
                    if !self.call_frames.is_empty() {
                        // Return takes the top value from the stack as the return value
                        let return_value = if !self.stack.is_empty() {
                            self.pop_one("Return")?
                        } else {
                            // If the stack is empty, default to 0.0
                            0.0
                        };
                        
                        // Store the return value in the current call frame
                        let frame = self.call_frames.last_mut().unwrap();
                        frame.return_value = Some(return_value);
                        
                        // Exit the current function execution
                        break;
                    }
                }
                
                Op::Nop => {}
                
                Op::Match { value, cases, default } => {
                    // Execute value operations to get match value
                    if !value.is_empty() {
                        self.execute_inner(value)?;
                    }
                    
                    // Get the value to match
                    let match_value = self.pop_one("Match")?;
                    
                    // Find matching case
                    let mut found_match = false;
                    for (case_value, case_ops) in cases {
                        if (match_value - *case_value).abs() < f64::EPSILON {
                            self.execute_inner(case_ops)?;
                            found_match = true;
                            break;
                        }
                    }
                    
                    // If no match found and there's a default block, execute it
                    if !found_match {
                        if let Some(default_block) = default {
                            self.execute_inner(default_block)?;
                        } else {
                            // If no default, push the value back
                            self.stack.push(match_value);
                        }
                    }
                }
                
                Op::AssertTop(expected) => {
                    let value = self.pop_one("AssertTop")?;
                    if (value - *expected).abs() >= f64::EPSILON {
                        return Err(VMError::AssertionFailed {
                            expected: *expected,
                            found: value,
                        });
                    }
                }
                
                Op::AssertMemory { key, expected } => {
                    let value = self.memory.get(key)
                        .ok_or_else(|| VMError::VariableNotFound(key.clone()))?;
                    if (value - expected).abs() >= f64::EPSILON {
                        return Err(VMError::AssertionFailed {
                            expected: *expected,
                            found: *value,
                        });
                    }
                }
            }
            
            pc += 1;
        }
        
        Ok(())
    }

    // These methods are used in tests
    #[cfg(test)]
    pub fn top(&self) -> Option<f64> {
        self.stack.last().copied()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, Write};
    use std::sync::Mutex;

    #[test]
    fn test_basic_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0),
            Op::Push(3.0),
            Op::Add,
            Op::Push(2.0),
            Op::Mul,
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(16.0));
    }

    #[test]
    fn test_division() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(10.0), Op::Push(2.0), Op::Div];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(5.0));
    }

    #[test]
    fn test_division_by_zero() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(10.0), Op::Push(0.0), Op::Div];

        assert_eq!(vm.execute(&ops), Err(VMError::DivisionByZero));
    }

    #[test]
    fn test_stack_underflow() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(5.0), Op::Add];

        assert_eq!(
            vm.execute(&ops),
            Err(VMError::StackUnderflow { 
                op: "Add".to_string(), 
                needed: 2, 
                found: 1 
            })
        );
    }

    #[test]
    fn test_store_and_load() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Store("x".to_string()),
            Op::Load("x".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
        assert_eq!(vm.get_memory("x"), Some(42.0));
    }

    #[test]
    fn test_load_nonexistent() {
        let mut vm = VM::new();
        let ops = vec![Op::Load("nonexistent".to_string())];

        assert_eq!(vm.execute(&ops), Err(VMError::VariableNotFound("nonexistent".to_string())));
    }

    #[test]
    fn test_store_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::Store("x".to_string())];

        assert_eq!(
            vm.execute(&ops),
            Err(VMError::StackUnderflow { 
                op: "Store".to_string(), 
                needed: 1, 
                found: 0 
            })
        );
    }

    #[test]
    fn test_memory_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(10.0),
            Op::Store("x".to_string()),
            Op::Push(5.0),
            Op::Store("y".to_string()),
            Op::Load("x".to_string()),
            Op::Load("y".to_string()),
            Op::Add,
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(15.0));
        assert_eq!(vm.get_memory("x"), Some(10.0));
        assert_eq!(vm.get_memory("y"), Some(5.0));
    }

    #[test]
    fn test_if_zero_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),  // Condition value is 0.0 (true in this VM)
            Op::If {
                condition: vec![],
                then: vec![Op::Push(42.0)],  // Should execute when condition is 0.0
                else_: None,
            },
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));  // Then block executed because condition was 0.0 (true)
    }

    #[test]
    fn test_if_zero_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(1.0),  // Condition value is non-zero (false in this VM)
            Op::If {
                condition: vec![],
                then: vec![Op::Push(42.0)],  // Should not execute
                else_: None,
            },
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));  // Then block not executed, original value remains
    }

    #[test]
    fn test_if_zero_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::If {
            condition: vec![],
            then: vec![Op::Push(42.0)],
            else_: None,
        }];

        assert_eq!(
            vm.execute(&ops),
            Err(VMError::StackUnderflow { 
                op: "If".to_string(), 
                needed: 1, 
                found: 0 
            })
        );
    }

    #[test]
    fn test_nested_if_zero() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),  // Initial stack value (true)
            Op::If {
                condition: vec![
                    Op::Push(1.0),  // Push false for outer condition
                    Op::If {
                        condition: vec![Op::Push(0.0)],  // Push true for inner condition
                        then: vec![Op::Push(42.0)],      // Should run (condition is true/0.0)
                        else_: None,
                    },
                ],
                then: vec![Op::Push(24.0)],  // This should run if the condition evaluates to 0.0
                else_: None,
            },
        ];

        assert!(vm.execute(&ops).is_ok());
        
        // The outer condition operation pushes 1.0 and then contains a nested if 
        // that leaves 42.0 on the stack. So the condition is 42.0, not 0.0, 
        // meaning the then block should not run, leaving 42.0 as the final result.
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_loop_basic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::Loop {
                count: 3,
                body: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("counter".to_string()),
                ],
            },
            Op::Load("counter".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(3.0));
    }

    #[test]
    fn test_loop_zero() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Store("value".to_string()),
            Op::Loop {
                count: 0,
                body: vec![Op::Push(100.0), Op::Store("value".to_string())],
            },
            Op::Load("value".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_nested_loops() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("outer".to_string()),
            Op::Push(0.0),
            Op::Store("inner".to_string()),
            Op::Loop {
                count: 2,
                body: vec![
                    Op::Load("outer".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("outer".to_string()),
                    Op::Loop {
                        count: 3,
                        body: vec![
                            Op::Load("inner".to_string()),
                            Op::Push(1.0),
                            Op::Add,
                            Op::Store("inner".to_string()),
                        ],
                    },
                ],
            },
            Op::Load("outer".to_string()),
            Op::Load("inner".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.get_memory("outer"), Some(2.0));
        assert_eq!(vm.get_memory("inner"), Some(6.0));
    }

    #[test]
    fn test_loop_with_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(1.0),
            Op::Store("result".to_string()),
            Op::Loop {
                count: 4,
                body: vec![
                    Op::Load("result".to_string()),
                    Op::Push(2.0),
                    Op::Mul,
                    Op::Store("result".to_string()),
                ],
            },
            Op::Load("result".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(16.0)); // 1 * 2^4
    }

    #[test]
    fn test_emit() {
        let mut vm = VM::new();
        let ops = vec![Op::Emit("Test message".to_string())];

        assert!(vm.execute(&ops).is_ok());
    }

    #[test]
    fn test_emit_with_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0),
            Op::Push(3.0),
            Op::Add,
            Op::Emit("Result:".to_string()),
            Op::Store("result".to_string()),
            Op::Load("result".to_string()),
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(8.0));
    }

    #[test]
    fn test_emit_in_loop() {
        let mut vm = VM::new();
        let ops = vec![Op::Loop {
            count: 3,
            body: vec![Op::Emit("Loop iteration".to_string())],
        }];

        assert!(vm.execute(&ops).is_ok());
    }

    #[test]
    fn test_negate() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Negate,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(-42.0));
    }

    #[test]
    fn test_negate_zero() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Negate,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_negate_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::Negate];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Negate".to_string(), 
            needed: 1, 
            found: 0 
        }));
    }

    #[test]
    fn test_negate_with_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0),
            Op::Push(3.0),
            Op::Add,
            Op::Negate,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(-8.0));
    }

    #[test]
    fn test_assert_top_success() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::AssertTop(42.0),
        ];
        
        assert!(vm.execute(&ops).is_ok());
    }

    #[test]
    fn test_assert_top_failure() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::AssertTop(24.0),
        ];
        
        assert_eq!(vm.execute(&ops), Err(VMError::AssertionFailed { 
            expected: 24.0, 
            found: 42.0 
        }));
    }

    #[test]
    fn test_assert_top_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::AssertTop(42.0)];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "AssertTop".to_string(), 
            needed: 1, 
            found: 0 
        }));
    }

    #[test]
    fn test_assert_top_with_arithmetic() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0),
            Op::Push(3.0),
            Op::Add,
            Op::AssertTop(8.0),
        ];
        
        assert!(vm.execute(&ops).is_ok());
    }

    #[test]
    fn test_dump_stack() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(1.0),
            Op::Push(2.0),
            Op::Push(3.0),
            Op::DumpStack,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![1.0, 2.0, 3.0]);
    }

    #[test]
    fn test_dump_memory() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Store("x".to_string()),
            Op::Push(24.0),
            Op::Store("y".to_string()),
            Op::DumpMemory,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.get_memory("x"), Some(42.0));
        assert_eq!(vm.get_memory("y"), Some(24.0));
    }

    #[test]
    fn test_dump_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::DumpStack];
        
        assert!(vm.execute(&ops).is_ok());
        assert!(vm.stack.is_empty());
    }

    #[test]
    fn test_dump_empty_memory() {
        let mut vm = VM::new();
        let ops = vec![Op::DumpMemory];
        
        assert!(vm.execute(&ops).is_ok());
        assert!(vm.memory.is_empty());
    }

    #[test]
    fn test_logic_not_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Not,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_logic_not_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Not,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));
    }

    #[test]
    fn test_logic_not_empty_stack() {
        let mut vm = VM::new();
        let ops = vec![Op::Not];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Not".to_string(), 
            needed: 1, 
            found: 0 
        }));
    }

    #[test]
    fn test_logic_and_true_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(24.0),
            Op::And,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));
    }

    #[test]
    fn test_logic_and_true_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(0.0),
            Op::And,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_logic_and_false_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Push(42.0),
            Op::And,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_logic_and_false_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Push(0.0),
            Op::And,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_logic_and_stack_underflow() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(42.0), Op::And];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "And".to_string(), 
            needed: 2, 
            found: 1 
        }));
    }

    #[test]
    fn test_logic_or_true_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(24.0),
            Op::Or,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));
    }

    #[test]
    fn test_logic_or_true_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(0.0),
            Op::Or,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));
    }

    #[test]
    fn test_logic_or_false_true() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Push(42.0),
            Op::Or,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(1.0));
    }

    #[test]
    fn test_logic_or_false_false() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Push(0.0),
            Op::Or,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_logic_or_stack_underflow() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(42.0), Op::Or];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Or".to_string(), 
            needed: 2, 
            found: 1 
        }));
    }

    #[test]
    fn test_while_countdown() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0),
            Op::Store("counter".to_string()),
            Op::While {
                condition: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(0.0),
                    Op::Gt,
                ],
                body: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Sub,
                    Op::Store("counter".to_string()),
                ],
            },
            Op::Load("counter".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_while_empty_condition() {
        let mut vm = VM::new();
        let ops = vec![
            Op::While {
                condition: vec![],
                body: vec![Op::Push(1.0)],
            }
        ];
        
        assert_eq!(
            vm.execute(&ops),
            Err(VMError::InvalidCondition("While condition block cannot be empty".to_string()))
        );
    }

    #[test]
    fn test_while_zero_condition() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::While {
                condition: vec![Op::Load("counter".to_string())],
                body: vec![Op::Push(42.0)],
            },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.get_memory("counter"), Some(0.0));
    }

    #[test]
    fn test_stack_dup() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Dup,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![42.0, 42.0]);
    }

    #[test]
    fn test_stack_dup_empty() {
        let mut vm = VM::new();
        let ops = vec![Op::Dup];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Dup".to_string(), 
            needed: 1, 
            found: 0 
        }));
    }

    #[test]
    fn test_stack_swap() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(24.0),
            Op::Swap,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![24.0, 42.0]);
    }

    #[test]
    fn test_stack_swap_underflow() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(42.0), Op::Swap];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Swap".to_string(), 
            needed: 2, 
            found: 1 
        }));
    }

    #[test]
    fn test_stack_over() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(24.0),
            Op::Over,
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![42.0, 24.0, 42.0]);
    }

    #[test]
    fn test_stack_over_underflow() {
        let mut vm = VM::new();
        let ops = vec![Op::Push(42.0), Op::Over];
        
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Over".to_string(), 
            needed: 2, 
            found: 1 
        }));
    }

    #[test]
    fn test_stack_manipulation_chain() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(1.0),
            Op::Push(2.0),
            Op::Push(3.0),
            Op::Dup,   // Stack: [1, 2, 3, 3]
            Op::Swap,  // Stack: [1, 2, 3, 3] -> [1, 2, 3, 3]
            Op::Over,  // Stack: [1, 2, 3, 3, 3]
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![1.0, 2.0, 3.0, 3.0, 3.0]);
    }

    #[test]
    fn test_function_definition_and_call() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "double".to_string(),
                params: vec![],
                body: vec![
                    Op::Push(2.0),
                    Op::Mul,
                ],
            },
            Op::Push(21.0),
            Op::Call("double".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_function_not_found() {
        let mut vm = VM::new();
        let ops = vec![Op::Call("nonexistent".to_string())];
        
        assert_eq!(vm.execute(&ops), Err(VMError::FunctionNotFound("nonexistent".to_string())));
    }

    #[test]
    fn test_function_return() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "add_one".to_string(),
                params: vec![],
                body: vec![
                    Op::Push(1.0),
                    Op::Add,
                    Op::Return,
                ],
            },
            Op::Push(41.0),
            Op::Call("add_one".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_function_with_memory() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "store_and_load".to_string(),
                params: vec![],
                body: vec![
                    Op::Store("x".to_string()),
                    Op::Load("x".to_string()),
                    Op::Return,
                ],
            },
            Op::Push(42.0),
            Op::Call("store_and_load".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_recursive_function() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "countdown".to_string(),
                params: vec![],
                body: vec![
                    Op::Dup,  // Duplicate the value for comparison
                    Op::Push(0.0),
                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
                    Op::If {
                        condition: vec![],
                        then: vec![
                            // Already 0, just return
                            Op::Push(0.0),  // Explicitly push 0 for the result
                        ],
                        else_: Some(vec![
                            // n > 0, so decrement and recurse
                            Op::Push(1.0),
                            Op::Sub,      // Decrement n
                            Op::Call("countdown".to_string()),  // Recursive call
                        ]),
                    },
                ],
            },
            Op::Push(3.0),  // Use a smaller number to avoid stack overflow
            Op::Call("countdown".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_function_stack_isolation() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "push_and_pop".to_string(),
                params: vec![],
                body: vec![
                    Op::Push(42.0),
                    Op::Pop,
                    Op::Return,
                ],
            },
            Op::Push(24.0),
            Op::Call("push_and_pop".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(24.0));
    }

    #[test]
    fn test_function_memory_isolation() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Store("x".to_string()),
            Op::Def {
                name: "store_value".to_string(),
                params: vec![],
                body: vec![
                    Op::Push(24.0),
                    Op::Store("x".to_string()),  // This should update the function's x, not global x
                    Op::Return,
                ],
            },
            Op::Call("store_value".to_string()),
            // No return value, so we need to load x to verify it's unchanged
            Op::Load("x".to_string()),  // Should be 42.0, not 24.0
        ];

        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));  // Global x should be 42.0
    }

    #[test]
    fn test_function_param_isolation() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "add_to_param".to_string(),
                params: vec!["x".to_string()],
                body: vec![
                    Op::Load("x".to_string()),
                    Op::Push(5.0),
                    Op::Add,
                    Op::Store("x".to_string()),  // Should modify the local x, not global x
                    Op::Load("x".to_string()),   // Should get the modified local x
                    Op::Return,
                ],
            },
            Op::Push(10.0),
            Op::Store("x".to_string()),  // Global x = 10
            Op::Push(20.0),              // Parameter value
            Op::Call("add_to_param".to_string()),  // Should return 25 (20+5)
            Op::Load("x".to_string()),   // Should still be 10 (global x unchanged)
        ];
         
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack.len(), 2);
        assert_eq!(vm.stack[0], 25.0);  // Return value from function (parameter + 5)
        assert_eq!(vm.stack[1], 10.0);  // Global x value unchanged
    }

    #[test]
    fn test_nested_function_calls() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "inner".to_string(),
                params: vec![],
                body: vec![
                    Op::Push(2.0),
                    Op::Mul,
                    Op::Return,
                ],
            },
            Op::Def {
                name: "outer".to_string(),
                params: vec![],
                body: vec![
                    Op::Call("inner".to_string()),
                    Op::Push(3.0),
                    Op::Mul,
                    Op::Return,
                ],
            },
            Op::Push(7.0),
            Op::Call("outer".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
    }

    #[test]
    fn test_function_with_named_params() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "add".to_string(),
                params: vec!["a".to_string(), "b".to_string()],
                body: vec![
                    Op::Load("a".to_string()),
                    Op::Load("b".to_string()),
                    Op::Add,
                    Op::Return,
                ],
            },
            Op::Push(20.0),
            Op::Push(22.0),
            Op::Call("add".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }

    #[test]
    fn test_function_missing_args() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "add".to_string(),
                params: vec!["x".to_string(), "y".to_string()],
                body: vec![
                    Op::Load("x".to_string()),
                    Op::Load("y".to_string()),
                    Op::Add,
                    Op::Return,
                ],
            },
            Op::Push(42.0),
            Op::Call("add".to_string()),
        ];
         
        assert_eq!(vm.execute(&ops), Err(VMError::StackUnderflow { 
            op: "Call to function 'add'".to_string(), 
            needed: 2, 
            found: 1 
        }));
    }

    #[test]
    fn test_recursive_function_with_params() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "countdown".to_string(),
                params: vec!["n".to_string()],
                body: vec![
                    Op::Load("n".to_string()),  // Load the parameter
                    Op::Push(0.0),
                    Op::Eq,   // Will push 1.0 if n==0, 0.0 otherwise
                    Op::If {
                        condition: vec![],
                        then: vec![
                            Op::Push(0.0),  // Return 0 when n==0
                        ],
                        else_: Some(vec![
                            // n > 0, so decrement and recurse
                            Op::Load("n".to_string()),
                            Op::Push(1.0),
                            Op::Sub,                       // Compute n-1
                            Op::Call("countdown".to_string()),  // Call countdown(n-1)
                        ]),
                    },
                    // Return (implicit)
                ],
            },
            Op::Push(5.0),
            Op::Call("countdown".to_string()),
        ];
         
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(0.0));
    }

    #[test]
    fn test_nested_function_calls_with_params() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Def {
                name: "inner".to_string(),
                params: vec!["x".to_string()],
                body: vec![
                    Op::Load("x".to_string()),
                    Op::Push(2.0),
                    Op::Mul,
                    Op::Return,
                ],
            },
            Op::Def {
                name: "outer".to_string(),
                params: vec!["x".to_string()],
                body: vec![
                    Op::Load("x".to_string()),
                    Op::Call("inner".to_string()),
                    Op::Push(3.0),
                    Op::Mul,
                    Op::Return,
                ],
            },
            Op::Push(7.0),
            Op::Call("outer".to_string()),
        ];
         
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0)); // 7 * 2 * 3
    }

    #[test]
    fn test_break_in_loop() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::Loop {
                count: 10,
                body: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("counter".to_string()),
                    Op::Load("counter".to_string()),
                    Op::Push(5.0),
                    Op::Eq,
                    Op::If {
                        condition: vec![],
                        then: vec![Op::Break],
                        else_: None,
                    },
                ],
            },
            Op::Load("counter".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(5.0)); // Loop should break at counter = 5
    }
    
    #[test]
    fn test_continue_in_loop() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("sum".to_string()),
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::Loop {
                count: 10,
                body: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("counter".to_string()),
                    
                    // Skip odd numbers
                    Op::Load("counter".to_string()),
                    Op::Push(2.0),
                    Op::Mod,
                    Op::Push(0.0),
                    Op::Eq,
                    Op::Not, // If counter % 2 != 0 (odd)
                    Op::If {
                        condition: vec![],
                        then: vec![Op::Continue],
                        else_: None,
                    },
                    
                    // Add even numbers to sum
                    Op::Load("sum".to_string()),
                    Op::Load("counter".to_string()),
                    Op::Add,
                    Op::Store("sum".to_string()),
                ],
            },
            Op::Load("sum".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
    }
    
    #[test]
    fn test_break_in_while() {
        let mut vm = VM::new();
        
        // Create a simpler test case that's more likely to work
        let ops = vec![
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::While {
                condition: vec![
                    Op::Push(0.0),  // True condition (0.0)
                ],
                body: vec![
                    // Increment counter
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("counter".to_string()),
                    
                    // If counter == 5, break
                    Op::Load("counter".to_string()),
                    Op::Push(5.0),
                    Op::Eq,
                    Op::If {
                        condition: vec![],
                        then: vec![Op::Break],
                        else_: None,
                    },
                ],
            },
            // Load the counter to verify
            Op::Load("counter".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(5.0));
    }
    
    #[test]
    fn test_continue_in_while() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(0.0),
            Op::Store("sum".to_string()),
            Op::Push(0.0),
            Op::Store("counter".to_string()),
            Op::While {
                condition: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(10.0),
                    Op::Lt,
                ],
                body: vec![
                    Op::Load("counter".to_string()),
                    Op::Push(1.0),
                    Op::Add,
                    Op::Store("counter".to_string()),
                    
                    // Skip odd numbers
                    Op::Load("counter".to_string()),
                    Op::Push(2.0),
                    Op::Mod,
                    Op::Push(0.0),
                    Op::Eq,
                    Op::Not, // If counter % 2 != 0 (odd)
                    Op::If {
                        condition: vec![],
                        then: vec![Op::Continue],
                        else_: None,
                    },
                    
                    // Add even numbers to sum
                    Op::Load("sum".to_string()),
                    Op::Load("counter".to_string()),
                    Op::Add,
                    Op::Store("sum".to_string()),
                ],
            },
            Op::Load("sum".to_string()),
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(30.0)); // Sum of even numbers from 2 to 10 = 2+4+6+8+10 = 30
    }
    
    #[test]
    fn test_match_statement() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(2.0), // Value to match
            Op::Match {
                value: vec![],
                cases: vec![
                    (1.0, vec![Op::Push(10.0)]),
                    (2.0, vec![Op::Push(20.0)]),
                    (3.0, vec![Op::Push(30.0)]),
                ],
                default: Some(vec![Op::Push(0.0)]),
            },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(20.0)); // Should match case 2
    }
    
    #[test]
    fn test_match_with_default() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0), // No matching case
            Op::Match {
                value: vec![],
                cases: vec![
                    (1.0, vec![Op::Push(10.0)]),
                    (2.0, vec![Op::Push(20.0)]),
                    (3.0, vec![Op::Push(30.0)]),
                ],
                default: Some(vec![Op::Push(999.0)]),
            },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(999.0)); // Should execute default
    }
    
    #[test]
    fn test_match_no_default() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(5.0), // No matching case
            Op::Match {
                value: vec![],
                cases: vec![
                    (1.0, vec![Op::Push(10.0)]),
                    (2.0, vec![Op::Push(20.0)]),
                    (3.0, vec![Op::Push(30.0)]),
                ],
                default: None,
            },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(5.0)); // Should keep original value
    }
    
    #[test]
    fn test_match_with_computed_value() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Match {
                value: vec![
                    Op::Push(1.0),
                    Op::Push(2.0),
                    Op::Add,
                ],
                cases: vec![
                    (1.0, vec![Op::Push(10.0)]),
                    (3.0, vec![Op::Push(30.0)]),
                    (4.0, vec![Op::Push(40.0)]),
                ],
                default: Some(vec![Op::Push(999.0)]),
            },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(30.0)); // 1+2=3, should match case 3
    }
    
    #[test]
    fn test_emit_event() {
        let mut vm = VM::new();
        let ops = vec![
            Op::EmitEvent {
                category: "governance".to_string(),
                message: "proposal submitted".to_string(),
            },
            Op::Push(42.0), // Just to verify execution continues
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.top(), Some(42.0));
    }
    
    #[test]
    fn test_assert_equal_stack_success() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(42.0),
            Op::Push(42.0),
            Op::AssertEqualStack { depth: 3 },
        ];
        
        assert!(vm.execute(&ops).is_ok());
        assert_eq!(vm.stack, vec![42.0, 42.0, 42.0]);
    }
    
    #[test]
    fn test_assert_equal_stack_failure() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::Push(24.0),
            Op::Push(42.0),
            Op::AssertEqualStack { depth: 3 },
        ];
        
        assert!(vm.execute(&ops).is_err());
    }
    
    #[test]
    fn test_assert_equal_stack_underflow() {
        let mut vm = VM::new();
        let ops = vec![
            Op::Push(42.0),
            Op::AssertEqualStack { depth: 3 },
        ];
        
        assert!(vm.execute(&ops).is_err());
    }
}
--- FILE: ./src/compiler.rs ---
use crate::vm::Op;
use thiserror::Error;

#[derive(Debug, Clone, PartialEq, Error)]
pub enum CompilerError {
    #[error("Unknown command: {0}")]
    UnknownCommand(String),
    
    #[error("Unknown block type: {0}")]
    UnknownBlockType(String),
    
    #[error("Invalid function definition: {0}")]
    InvalidFunctionDefinition(String),
    
    #[error("Invalid function definition format: {0}")]
    InvalidFunctionFormat(String),
    
    #[error("Function definition must start with 'def': {0}")]
    InvalidFunctionStart(String),
    
    #[error("Missing number for push")]
    MissingPushValue,
    
    #[error("Invalid number for push: {0}")]
    InvalidPushValue(String),
    
    #[error("Missing quotes for emit command")]
    MissingEmitQuotes,
    
    #[error("Invalid format for emitevent, expected: emitevent \"category\" \"message\"")]
    InvalidEmitEventFormat,
    
    #[error("Missing variable for {0}")]
    MissingVariable(String),
    
    #[error("Missing function name for call")]
    MissingFunctionName,
    
    #[error("Missing depth for assertequalstack")]
    MissingAssertDepth,
    
    #[error("Invalid depth for assertequalstack: {0}")]
    InvalidAssertDepth(String),
    
    #[error("Depth for assertequalstack must be at least 2")]
    InsufficientAssertDepth,
    
    #[error("Invalid case value: {0}")]
    InvalidCaseValue(String),
    
    #[error("Match statement must have a value block")]
    MissingMatchValue,
    
    #[error("Invalid loop format: {0}")]
    InvalidLoopFormat(String),
    
    #[error("Invalid loop count: {0}")]
    InvalidLoopCount(String),
}

pub fn parse_dsl(source: &str) -> Result<Vec<Op>, CompilerError> {
    let lines: Vec<String> = source.lines().map(|s| s.to_string()).collect();
    let mut current_line = 0;
    let mut ops = Vec::new();

    while current_line < lines.len() {
        let line = &lines[current_line];
        if line.trim().is_empty() {
            current_line += 1;
            continue;
        }

        let op = if line.trim().ends_with(':') {
            if line.trim() == "if:" {
                parse_if_statement(&lines, &mut current_line)?
            } else if line.trim() == "while:" {
                parse_while_statement(&lines, &mut current_line)?
            } else if line.trim().starts_with("def ") {
                parse_function_definition(&lines, &mut current_line)?
            } else if line.trim() == "match:" {
                parse_match_statement(&lines, &mut current_line)?
            } else if line.trim().starts_with("loop ") {
                parse_loop_statement(&lines, &mut current_line)?
            } else {
                return Err(CompilerError::UnknownBlockType(line.trim().to_string()));
            }
        } else {
            parse_line(line)?
        };

        if !matches!(op, Op::Nop) {
            ops.push(op);
        }
        current_line += 1;
    }

    Ok(ops)
}

fn parse_function_signature(line: &str) -> Result<(String, Vec<String>), CompilerError> {
    // Format: def name(x, y):
    let parts: Vec<&str> = line.trim_end_matches(':').splitn(2, '(').collect();
    if parts.len() != 2 {
        return Err(CompilerError::InvalidFunctionDefinition(line.to_string()));
    }

    let name = parts[0].trim_start_matches("def").trim().to_string();
    let params_str = parts[1].trim_end_matches(')');
    let params: Vec<String> = params_str
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    Ok((name, params))
}

fn parse_line(line: &str) -> Result<Op, CompilerError> {
    // Skip comments
    if line.trim().starts_with('#') {
        return Ok(Op::Nop);
    }

    let mut parts = line.split_whitespace();
    let command = match parts.next() {
        Some(cmd) => cmd,
        None => return Ok(Op::Nop),
    };

    match command {
        "push" => {
            let num_str = parts.next().ok_or(CompilerError::MissingPushValue)?;
            let num = num_str.parse::<f64>()
                .map_err(|_| CompilerError::InvalidPushValue(num_str.to_string()))?;
            Ok(Op::Push(num))
        }
        "emit" => {
            if let Some(inner) = line.find('"') {
                let inner = &line[inner + 1..line.rfind('"').unwrap_or(line.len())];
                Ok(Op::Emit(inner.to_string()))
            } else {
                Err(CompilerError::MissingEmitQuotes)
            }
        }
        "emitevent" => {
            // Format: emitevent "category" "message"
            let line_str = line.to_string();
            let parts: Vec<&str> = line_str.split('"').collect();
            if parts.len() < 5 {
                return Err(CompilerError::InvalidEmitEventFormat);
            }
            
            let category = parts[1].trim().to_string();
            let message = parts[3].trim().to_string();
            
            Ok(Op::EmitEvent { category, message })
        }
        "assertequalstack" => {
            let depth_str = parts.next().ok_or(CompilerError::MissingAssertDepth)?;
            let depth = depth_str.parse::<usize>()
                .map_err(|_| CompilerError::InvalidAssertDepth(depth_str.to_string()))?;
            
            if depth < 2 {
                return Err(CompilerError::InsufficientAssertDepth);
            }
            
            Ok(Op::AssertEqualStack { depth })
        }
        "break" => Ok(Op::Break),
        "continue" => Ok(Op::Continue),
        "load" => Ok(Op::Load(
            parts.next().ok_or(CompilerError::MissingVariable("load".to_string()))?.to_string(),
        )),
        "store" => Ok(Op::Store(
            parts.next().ok_or(CompilerError::MissingVariable("store".to_string()))?.to_string(),
        )),
        "add" => Ok(Op::Add),
        "sub" => Ok(Op::Sub),
        "mul" => Ok(Op::Mul),
        "div" => Ok(Op::Div),
        "mod" => Ok(Op::Mod),
        "eq" => Ok(Op::Eq),
        "gt" => Ok(Op::Gt),
        "lt" => Ok(Op::Lt),
        "not" => Ok(Op::Not),
        "and" => Ok(Op::And),
        "or" => Ok(Op::Or),
        "negate" => Ok(Op::Negate),
        "dup" => Ok(Op::Dup),
        "swap" => Ok(Op::Swap),
        "over" => Ok(Op::Over),
        "pop" => Ok(Op::Pop),
        "return" => Ok(Op::Return),
        "call" => Ok(Op::Call(
            parts.next().ok_or(CompilerError::MissingFunctionName)?.to_string(),
        )),
        "dumpstack" => Ok(Op::DumpStack),
        "dumpmemory" => Ok(Op::DumpMemory),
        _ => Err(CompilerError::UnknownCommand(command.to_string())),
    }
}

fn get_indent(line: &str) -> usize {
    line.chars().take_while(|c| c.is_whitespace()).count()
}

fn parse_if_statement(lines: &[String], current_line: &mut usize) -> Result<Op, CompilerError> {
    let mut condition = Vec::new();
    let mut then_block = Vec::new();
    let mut else_block = None;
    let mut current_indent = get_indent(&lines[*current_line]);

    // Skip the "if:" line
    *current_line += 1;

    // Parse the then block
    while *current_line < lines.len() {
        let line = &lines[*current_line];
        let indent = get_indent(line);
        
        if indent <= current_indent {
            break;
        }

        // Check for nested if
        if line.trim() == "if:" {
            let nested_if = parse_if_statement(lines, current_line)?;
            then_block.push(nested_if);
            continue; // parse_if_statement already incremented current_line
        }

        let op = parse_line(line)?;
        if !matches!(op, Op::Nop) {
            then_block.push(op);
        }
        *current_line += 1;
    }

    // Check for else block
    if *current_line < lines.len() && lines[*current_line].trim() == "else:" {
        *current_line += 1;
        let mut else_ops = Vec::new();

        while *current_line < lines.len() {
            let line = &lines[*current_line];
            let indent = get_indent(line);
            
            if indent <= current_indent {
                break;
            }

            // Check for nested if in else block
            if line.trim() == "if:" {
                let nested_if = parse_if_statement(lines, current_line)?;
                else_ops.push(nested_if);
                continue; // parse_if_statement already incremented current_line
            }

            let op = parse_line(line)?;
            if !matches!(op, Op::Nop) {
                else_ops.push(op);
            }
            *current_line += 1;
        }

        else_block = Some(else_ops);
    }

    Ok(Op::If {
        condition,
        then: then_block,
        else_: else_block,
    })
}

fn parse_function_definition(lines: &[String], current_line: &mut usize) -> Result<Op, CompilerError> {
    let line = &lines[*current_line];
    
    // Expected format: def name(param1, param2):
    if !line.contains('(') || !line.contains(')') {
        return Err(CompilerError::InvalidFunctionFormat(line.to_string()));
    }
    
    // Extract name and parameters
    let parts = line.trim().split('(').collect::<Vec<&str>>();
    if parts.len() != 2 {
        return Err(CompilerError::InvalidFunctionDefinition(line.to_string()));
    }
    
    let name_part = parts[0].trim();
    if !name_part.starts_with("def ") {
        return Err(CompilerError::InvalidFunctionStart(line.to_string()));
    }
    
    let name = name_part["def ".len()..].trim().to_string();
    
    // Extract parameters
    let params_part = parts[1].split(')').next().unwrap().trim();
    let params: Vec<String> = params_part
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    
    let mut body = Vec::new();
    let current_indent = get_indent(line);
    *current_line += 1;
    
    // Parse function body
    while *current_line < lines.len() {
        let line = &lines[*current_line];
        let indent = get_indent(line);
        
        if indent <= current_indent {
            break;
        }
        
        let op = parse_line(line)?;
        if !matches!(op, Op::Nop) {
            body.push(op);
        }
        *current_line += 1;
    }
    
    Ok(Op::Def {
        name,
        params,
        body,
    })
}

fn parse_loop_statement(lines: &[String], current_line: &mut usize) -> Result<Op, CompilerError> {
    // Parse the "loop N:" line, extracting N
    let line = &lines[*current_line];
    let parts: Vec<&str> = line.trim().splitn(2, ' ').collect();
    if parts.len() != 2 || !parts[0].eq_ignore_ascii_case("loop") {
        return Err(CompilerError::InvalidLoopFormat(line.trim().to_string()));
    }
    
    let count_str = parts[1].trim_end_matches(':');
    let count = count_str.parse::<usize>()
        .map_err(|_| CompilerError::InvalidLoopCount(count_str.to_string()))?;
    
    let mut body = Vec::new();
    let current_indent = get_indent(line);
    
    // Skip the "loop N:" line
    *current_line += 1;
    
    // Parse the body
    while *current_line < lines.len() {
        let line = &lines[*current_line];
        let indent = get_indent(line);
        
        if indent <= current_indent {
            break;
        }
        
        // Handle nested blocks inside the loop body
        if line.trim().ends_with(':') {
            if line.trim() == "if:" {
                body.push(parse_if_statement(lines, current_line)?);
                continue;
            } else if line.trim() == "while:" {
                body.push(parse_while_statement(lines, current_line)?);
                continue;
            } else if line.trim().starts_with("loop ") {
                body.push(parse_loop_statement(lines, current_line)?);
                continue;
            } else if line.trim() == "match:" {
                body.push(parse_match_statement(lines, current_line)?);
                continue;
            } else {
                return Err(CompilerError::UnknownBlockType(line.trim().to_string()));
            }
        }
        
        let op = parse_line(line)?;
        if !matches!(op, Op::Nop) {
            body.push(op);
        }
        *current_line += 1;
    }
    
    Ok(Op::Loop { count, body })
}

fn parse_while_statement(lines: &[String], current_line: &mut usize) -> Result<Op, CompilerError> {
    let mut condition = Vec::new();
    let mut body = Vec::new();
    let mut current_indent = get_indent(&lines[*current_line]);
    let mut parsing_condition = true;

    // Skip the "while:" line
    *current_line += 1;

    // Parse the body, looking for an explicit condition: block
    while *current_line < lines.len() {
        let line = &lines[*current_line];
        let indent = get_indent(line);
        
        if indent <= current_indent {
            break;
        }

        // Check for condition: marker
        if line.trim() == "condition:" && parsing_condition {
            parsing_condition = false;
            *current_line += 1;
            let condition_indent = indent;
            
            // Parse condition block
            while *current_line < lines.len() {
                let line = &lines[*current_line];
                let current_indent = get_indent(line);
                
                if current_indent <= condition_indent {
                    break;
                }
                
                let op = parse_line(line)?;
                if !matches!(op, Op::Nop) {
                    condition.push(op);
                }
                *current_line += 1;
            }
        } else if line.trim().ends_with(':') {
            // Handle nested block structures
            if line.trim() == "if:" {
                body.push(parse_if_statement(lines, current_line)?);
            } else if line.trim() == "while:" {
                body.push(parse_while_statement(lines, current_line)?);
            } else if line.trim().starts_with("loop ") {
                body.push(parse_loop_statement(lines, current_line)?);
            } else if line.trim() == "match:" {
                body.push(parse_match_statement(lines, current_line)?);
            } else {
                return Err(CompilerError::UnknownBlockType(line.trim().to_string()));
            }
        } else {
            // Regular statement in body
            let op = parse_line(line)?;
            if !matches!(op, Op::Nop) {
                body.push(op);
            }
            *current_line += 1;
        }
    }

    Ok(Op::While {
        condition,
        body,
    })
}

fn parse_match_statement(lines: &[String], current_line: &mut usize) -> Result<Op, CompilerError> {
    let mut value_ops = Vec::new();
    let mut cases = Vec::new();
    let mut default_ops = None;
    let current_indent = get_indent(&lines[*current_line]);
    
    // Skip the "match:" line
    *current_line += 1;
    
    // First line after match should be the value block
    while *current_line < lines.len() {
        let line = &lines[*current_line];
        let indent = get_indent(line);
        
        if indent <= current_indent {
            break;
        }
        
        if line.trim() == "value:" {
            *current_line += 1;
            let value_indent = indent;
            
            // Parse the value block
            while *current_line < lines.len() {
                let line = &lines[*current_line];
                let current_indent = get_indent(line);
                
                if current_indent <= value_indent {
                    break;
                }
                
                let op = parse_line(line)?;
                if !matches!(op, Op::Nop) {
                    value_ops.push(op);
                }
                *current_line += 1;
            }
        } else if line.trim().starts_with("case ") {
            // Parse case value
            let case_line = line.trim();
            let case_value_str = case_line[5..].trim().trim_end_matches(':');
            let case_value = case_value_str.parse::<f64>()
                .map_err(|_| CompilerError::InvalidCaseValue(case_value_str.to_string()))?;
            
            let case_indent = indent;
            *current_line += 1;
            
            let mut case_ops = Vec::new();
            
            // Parse case block
            while *current_line < lines.len() {
                let line = &lines[*current_line];
                let current_indent = get_indent(line);
                
                if current_indent <= case_indent {
                    break;
                }
                
                let op = parse_line(line)?;
                if !matches!(op, Op::Nop) {
                    case_ops.push(op);
                }
                *current_line += 1;
            }
            
            cases.push((case_value, case_ops));
        } else if line.trim() == "default:" {
            *current_line += 1;
            let default_indent = indent;
            
            let mut default_block = Vec::new();
            
            // Parse default block
            while *current_line < lines.len() {
                let line = &lines[*current_line];
                let current_indent = get_indent(line);
                
                if current_indent <= default_indent {
                    break;
                }
                
                let op = parse_line(line)?;
                if !matches!(op, Op::Nop) {
                    default_block.push(op);
                }
                *current_line += 1;
            }
            
            default_ops = Some(default_block);
        } else {
            // If not in a special block, assume it's part of the value
            let op = parse_line(line)?;
            if !matches!(op, Op::Nop) {
                value_ops.push(op);
            }
            *current_line += 1;
        }
    }
    
    if value_ops.is_empty() {
        return Err(CompilerError::MissingMatchValue);
    }
    
    Ok(Op::Match {
        value: value_ops,
        cases,
        default: default_ops,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vm::Op;

    #[test]
    fn test_simple_push_emit() {
        let source = r#"push 42
emit "hello world""#;
        let ops = parse_dsl(source).unwrap();
        assert_eq!(
            ops,
            vec![Op::Push(42.0), Op::Emit("hello world".to_string())]
        );
    }

    #[test]
    fn test_function_definition() {
        let source = r#"
def add(x, y):
    load x
    load y
    add
    return
"#;
        let ops = parse_dsl(source).unwrap();
        match &ops[0] {
            Op::Def { name, params, body } => {
                assert_eq!(name, "add");
                assert_eq!(params, &vec!["x".to_string(), "y".to_string()]);
                assert_eq!(
                    body,
                    &vec![
                        Op::Load("x".to_string()),
                        Op::Load("y".to_string()),
                        Op::Add,
                        Op::Return
                    ]
                );
            }
            _ => panic!("Expected function definition"),
        }
    }

    #[test]
    fn test_invalid_instruction() {
        let result = parse_dsl("foobar");
        assert!(result.is_err());
    }

    #[test]
    fn test_emit_without_quotes() {
        let result = parse_dsl("emit hello");
        assert!(result.is_err());
    }

    #[test]
    fn test_if_statement() {
        let source = r#"
push 1
if:
    push 42
else:
    push 24
"#;
        let ops = parse_dsl(source).unwrap();
        assert_eq!(
            ops,
            vec![
                Op::Push(1.0),
                Op::If {
                    condition: vec![],
                    then: vec![Op::Push(42.0)],
                    else_: Some(vec![Op::Push(24.0)])
                }
            ]
        );
    }

    #[test]
    fn test_nested_if() {
        let source = r#"push 1
if:
    push 2
    if:
        push 3
    else:
        push 4
else:
    push 5"#;
        let ops = parse_dsl(source).unwrap();
        assert_eq!(
            ops,
            vec![
                Op::Push(1.0),
                Op::If {
                    condition: vec![],
                    then: vec![
                        Op::Push(2.0),
                        Op::If {
                            condition: vec![],
                            then: vec![Op::Push(3.0)],
                            else_: Some(vec![Op::Push(4.0)])
                        }
                    ],
                    else_: Some(vec![Op::Push(5.0)])
                }
            ]
        );
    }

    #[test]
    fn test_break_continue() {
        let source = r#"
# Test break in loop
push 0
store counter
loop 10:
    load counter
    push 1
    add
    store counter
    load counter
    push 5
    eq
    if:
        break
"#;
        let ops = parse_dsl(source).unwrap();
        
        // Verify loop with break
        assert_eq!(
            ops,
            vec![
                Op::Push(0.0),
                Op::Store("counter".to_string()),
                Op::Loop {
                    count: 10,
                    body: vec![
                        Op::Load("counter".to_string()),
                        Op::Push(1.0),
                        Op::Add,
                        Op::Store("counter".to_string()),
                        Op::Load("counter".to_string()),
                        Op::Push(5.0),
                        Op::Eq,
                        Op::If {
                            condition: vec![],
                            then: vec![Op::Break],
                            else_: None,
                        },
                    ],
                },
            ]
        );
    }
    
    #[test]
    fn test_emitevent() {
        let source = r#"emitevent "governance" "proposal accepted""#;
        let ops = parse_dsl(source).unwrap();
        assert_eq!(
            ops,
            vec![
                Op::EmitEvent {
                    category: "governance".to_string(),
                    message: "proposal accepted".to_string(),
                },
            ]
        );
    }
    
    #[test]
    fn test_assertequalstack() {
        let source = r#"
push 42
push 42
push 42
assertequalstack 3
"#;
        let ops = parse_dsl(source).unwrap();
        assert_eq!(
            ops,
            vec![
                Op::Push(42.0),
                Op::Push(42.0),
                Op::Push(42.0),
                Op::AssertEqualStack { depth: 3 },
            ]
        );
    }
    
    #[test]
    fn test_match_statement() {
        let source = r#"
match:
    push 2
    case 1:
        push 10
    case 2:
        push 20
    case 3:
        push 30
    default:
        push 0
"#;
        
        let ops = parse_dsl(source).unwrap();
        
        assert_eq!(
            ops,
            vec![
                Op::Match {
                    value: vec![Op::Push(2.0)],
                    cases: vec![
                        (1.0, vec![Op::Push(10.0)]),
                        (2.0, vec![Op::Push(20.0)]),
                        (3.0, vec![Op::Push(30.0)]),
                    ],
                    default: Some(vec![Op::Push(0.0)]),
                }
            ]
        );
    }
    
    #[test]
    fn test_match_with_computed_value() {
        let source = r#"
match:
    value:
        push 1
        push 2
        add
    case 3:
        push 30
"#;
        let ops = parse_dsl(source).unwrap();
        
        match &ops[0] {
            Op::Match { value, cases, default } => {
                assert_eq!(value, &vec![Op::Push(1.0), Op::Push(2.0), Op::Add]);
                assert_eq!(cases.len(), 1);
                assert_eq!(cases[0], (3.0, vec![Op::Push(30.0)]));
                assert!(default.is_none());
            }
            _ => panic!("Expected match statement"),
        }
    }
    
    #[test]
    fn test_invalid_match() {
        // Missing value block
        let source = r#"
match:
    case 1:
        push 10
"#;
        assert!(parse_dsl(source).is_err());
        
        // Invalid case value
        let source = r#"
match:
    value:
        push 1
    case invalid:
        push 10
"#;
        assert!(parse_dsl(source).is_err());
    }
} --- FILE: ./tests/integration.rs ---
use std::fs;
use std::path::Path;
use serde_json;
use nano_cvm::{Op, VM};

#[test]
fn test_program_json_runs_correctly() -> Result<(), Box<dyn std::error::Error>> {
    // Read and parse program.json
    let program_path = Path::new("program.json");
    let program_json = fs::read_to_string(program_path)?;
    let ops: Vec<Op> = serde_json::from_str(&program_json)?;

    // Create and run VM
    let mut vm = VM::new();
    vm.execute(&ops)?;

    // Print debug info
    println!("\nFinal stack:");
    for (i, &value) in vm.get_stack().iter().enumerate() {
        println!("  {}: {}", i, value);
    }

    Ok(())
}

#[test]
fn test_governance_operations() -> Result<(), Box<dyn std::error::Error>> {
    // Create a program that uses all governance-inspired opcodes
    let ops = vec![
        // Test Match opcode with value computed on stack
        Op::Push(1.0),
        Op::Push(2.0),
        Op::Add,
        Op::Match {
            value: vec![],  // Empty - use value on stack
            cases: vec![
                (3.0, vec![Op::Push(42.0)]),  // Should match 3
                (4.0, vec![Op::Push(24.0)]),
            ],
            default: Some(vec![Op::Push(0.0)]),
        },
        
        // Test AssertEqualStack
        Op::Dup,
        Op::Dup,
        Op::AssertEqualStack { depth: 3 },
        
        // Test EmitEvent
        Op::EmitEvent { 
            category: "test".to_string(), 
            message: "governance operations test".to_string() 
        },
        
        // Test Break in Loop
        Op::Push(0.0),
        Op::Store("counter".to_string()),
        Op::Loop {
            count: 10,
            body: vec![
                Op::Load("counter".to_string()),
                Op::Push(1.0),
                Op::Add,
                Op::Store("counter".to_string()),
                Op::Load("counter".to_string()),
                Op::Push(5.0),
                Op::Eq,
                Op::If {
                    condition: vec![],
                    then: vec![Op::Break],
                    else_: None,
                },
            ],
        },
        Op::Load("counter".to_string()),
        
        // Test Continue in While
        Op::Push(0.0),
        Op::Store("sum".to_string()),
        Op::Push(0.0),
        Op::Store("i".to_string()),
        Op::While {
            condition: vec![
                Op::Load("i".to_string()),
                Op::Push(5.0),
                Op::Lt,
            ],
            body: vec![
                Op::Load("i".to_string()),
                Op::Push(1.0),
                Op::Add, 
                Op::Store("i".to_string()),
                
                // Skip odd numbers
                Op::Load("i".to_string()),
                Op::Push(2.0),
                Op::Mod,
                Op::Push(0.0),
                Op::Eq,
                Op::Not,
                Op::If {
                    condition: vec![],
                    then: vec![Op::Continue],
                    else_: None,
                },
                
                // Add even numbers
                Op::Load("sum".to_string()),
                Op::Load("i".to_string()),
                Op::Add,
                Op::Store("sum".to_string()),
            ],
        },
        Op::Load("sum".to_string()),
    ];

    // Create and run VM
    let mut vm = VM::new();
    vm.execute(&ops)?;

    // Verify results
    let stack = vm.get_stack();
    assert_eq!(stack.len(), 3);
    assert_eq!(stack[0], 42.0);  // Result of Match operation
    assert_eq!(stack[1], 5.0);   // Result of Break test
    assert_eq!(stack[2], 6.0);   // Result of Continue test (sum of 2+4)

    // Verify memory
    assert_eq!(vm.get_memory("counter"), Some(5.0));
    assert_eq!(vm.get_memory("sum"), Some(6.0));
    assert_eq!(vm.get_memory("i"), Some(5.0));

    Ok(())
} --- FILE: ./.cursor/rules/rust.json ---
{
    "$schema": "https://cursor.sh/schemas/rules.json",
    "description": "Cursor automation rules for nano-cvm Rust VM project",
    "globs": ["**/*.rs"],
    "rules": [
      {
        "when": "saving",
        "do": [
          "run: cargo fmt",
          "run: cargo clippy -- -D warnings"
        ]
      },
      {
        "when": "before committing",
        "do": [
          "run: cargo test",
          "remind: Are all new features covered by unit tests?",
          "remind: Is your commit message clear, descriptive, and concise?",
          "remind: Are you on a feature branch? Avoid committing directly to main."
        ]
      },
      {
        "when": "creating new files",
        "do": [
          "remind: Should this file include module-level docs or comments?",
          "remind: Should this file contain unit tests if logic is added?",
          "remind: Is this file used in main, tests, or VM execution path?"
        ]
      },
      {
        "when": "creating a new branch",
        "do": [
          "remind: Use feature/ or fix/ prefix to follow branch naming conventions",
          "remind: Are you branching off the latest main?"
        ]
      },
      {
        "when": "modifying: src/vm.rs",
        "do": [
          "remind: Did you write or update unit tests for this logic?",
          "remind: Does this change affect VM state, recursion, or memory?"
        ]
      },
      {
        "when": "modifying: src/main.rs",
        "do": [
          "remind: Should CLI behavior or input/output handling be tested?",
          "remind: Should user feedback be logged or emitted?"
        ]
      },
      {
        "when": "modifying: program.json",
        "do": [
          "remind: Is this program meant to test a new opcode or feature?",
          "remind: Should this be added to a test suite or sample directory?"
        ]
      }
    ]
  }
  --- FILE: ./.cursor/rules/intent.md ---
# Cursor AI Rules for `nano-cvm`

##  Rust Code Standards

- Always write safe, idiomatic Rust
- Use pattern matching and enums over magic values
- Prefer small, focused functions and clean match arms
- Derive `Debug` and `Serialize`/`Deserialize` for data structures where appropriate
- Avoid unsafe blocks unless explicitly instructed

##  Virtual Machine Design

- The VM uses a stack-based architecture with memory and control flow
- All opcodes (`Op` enum) must be serializable with Serde
- Every new `Op` should include:
  - Execution logic inside `execute()`
  - A JSON-compatible serialization format
  - Unit tests in `#[cfg(test)]` module
  - Optional usage in `program.json` for demonstration

##  Testing Expectations

- Every new operation must be tested:
  - Functionality (`test_opcode_name`)
  - Edge cases (stack underflow, invalid memory, etc.)
  - Nested/recursive use if applicable (e.g., loops, conditionals)
- Do not add new logic without corresponding tests unless explicitly instructed

##  Workflow Rules

- New logic should generally be added on a feature branch
- Prompt user to write clean, concise commit messages
- Encourage testing before merge
- Use semantic and descriptive branch names (e.g., `feature/emit`, `fix/loop-bug`)

##  JSON DSL Rules

- JSON input programs must match the `Vec<Op>` structure
- Each opcode should have a clear JSON form (e.g., `{ "Emit": "hello" }`)
- Maintain simplicity and readability of example JSON programs
- Nesting (e.g., `IfZero`, `Loop`) should be kept consistent and easy to interpret

##  Prompt Behavior

- When user asks to add a new `Op`, always include:
  - Enum addition
  - Execute match logic
  - Serde support
  - Unit tests
  - JSON usage demo
- Ask the user if they want CLI, REPL, export, or interactive features when appropriate
- Be mindful of execution state (stack/memory) when designing new logic

##  Running the Program

To run the program, use the following command:

```bash
cargo run
```

This will start the calculation and output the final result.
--- FILE: ./program.json ---
[
  { "Emit": "Defining functions..." },
  { "Def": {
    "name": "add",
    "params": ["x", "y"],
    "body": [
      { "Load": "x" },
      { "Load": "y" },
      { "Add": null },
      { "Return": null }
    ]
  }},
  { "Def": {
    "name": "multiply_and_print",
    "params": ["x", "y"],
    "body": [
      { "Load": "x" },
      { "Emit": "First number:" },
      { "Load": "y" },
      { "Emit": "Second number:" },
      { "Load": "x" },
      { "Load": "y" },
      { "Mul": null },
      { "Emit": "Product:" },
      { "Return": null }
    ]
  }},
  { "Def": {
    "name": "countdown",
    "params": ["n"],
    "body": [
      { "Load": "n" },
      { "Push": 0.0 },
      { "Lt": null },
      {
        "If": {
          "condition": [],
          "then": [
            { "Push": 0.0 },
            { "Return": null }
          ],
          "else_": [
            { "Load": "n" },
            { "Emit": "Current value:" },
            { "Load": "n" },
            { "Push": 1.0 },
            { "Sub": null },
            { "Store": "n" },
            { "Load": "n" },
            { "Push": 0.0 },
            { "Gt": null },
            {
              "If": {
                "condition": [],
                "then": [
                  { "Load": "n" },
                  { "Call": "countdown" }
                ],
                "else_": [
                  { "Push": 0.0 }
                ]
              }
            },
            { "Return": null }
          ]
        }
      }
    ]
  }},
  { "Emit": "Testing add with 20 and 22:" },
  { "Push": 20.0 },
  { "Push": 22.0 },
  { "Call": "add" },
  { "Emit": "Testing multiply_and_print with 6 and 7:" },
  { "Push": 6.0 },
  { "Push": 7.0 },
  { "Call": "multiply_and_print" },
  { "Emit": "Starting countdown from 5:" },
  { "Push": 5.0 },
  { "Call": "countdown" },
  { "Emit": "Stack manipulation demo:" },
  { "Push": 1.0 },
  { "Push": 2.0 },
  { "Push": 3.0 },
  { "Dup": null },
  { "Swap": null },
  { "Over": null },
  { "DumpStack": null },
  { "Emit": "Governance-inspired opcodes demonstration" },
  
  { "Def": {
    "name": "process_votes",
    "params": ["proposal_id", "support_votes", "against_votes"],
    "body": [
      { "Load": "support_votes" },
      { "Load": "against_votes" },
      { "Add": null },
      { "Store": "total_votes" },
      
      { "Load": "support_votes" },
      { "Push": 100.0 },
      { "Mul": null },
      { "Load": "total_votes" },
      { "Div": null },
      { "Store": "support_percentage" },
      
      { "EmitEvent": {
        "category": "governance",
        "message": "Votes processed for proposal"
      }},
      
      { "Load": "support_percentage" },
      { "Match": {
        "value": [],
        "cases": [
          [50.0, [
            { "EmitEvent": {
              "category": "governance",
              "message": "Exact tie - proposal is rejected"
            }},
            { "Push": 0.0 },
            { "Return": null }
          ]],
          [66.0, [
            { "EmitEvent": {
              "category": "governance",
              "message": "Exact 66% support - proposal passes threshold"
            }},
            { "Push": 1.0 },
            { "Return": null }
          ]]
        ],
        "default": [
          { "Load": "support_percentage" },
          { "Push": 67.0 },
          { "Lt": null },
          { "If": {
            "condition": [],
            "then": [
              { "EmitEvent": {
                "category": "governance",
                "message": "Proposal rejected - insufficient support"
              }},
              { "Push": 0.0 }
            ],
            "else_": [
              { "EmitEvent": {
                "category": "governance",
                "message": "Proposal approved with supermajority"
              }},
              { "Push": 1.0 }
            ]
          }},
          { "Return": null }
        ]
      }}
    ]
  }},
  
  { "EmitEvent": {
    "category": "governance",
    "message": "Starting governance simulation"
  }},
  
  { "Push": 3.0 },
  { "Store": "proposal_count" },
  
  { "Push": 0.0 },
  { "Store": "current_proposal" },
  
  { "While": {
    "condition": [
      { "Load": "current_proposal" },
      { "Load": "proposal_count" },
      { "Lt": null }
    ],
    "body": [
      { "Load": "current_proposal" },
      { "Emit": "Processing proposal" },
      
      { "Load": "current_proposal" },
      { "Push": 2.0 },
      { "Mod": null },
      { "Push": 0.0 },
      { "Eq": null },
      { "If": {
        "condition": [],
        "then": [
          { "EmitEvent": {
            "category": "governance",
            "message": "Skipping even-numbered proposal"
          }},
          { "Load": "current_proposal" },
          { "Push": 1.0 },
          { "Add": null },
          { "Store": "current_proposal" },
          { "Continue": null }
        ],
        "else_": null
      }},
      
      { "Load": "current_proposal" },
      { "Push": 1.0 },
      { "Eq": null },
      { "If": {
        "condition": [],
        "then": [
          { "EmitEvent": {
            "category": "governance",
            "message": "Critical proposal detected"
          }},
          { "EmitEvent": {
            "category": "governance",
            "message": "Emergency protocol activated"
          }},
          { "Break": null }
        ],
        "else_": null
      }},
      
      { "Push": 135.0 },
      { "Store": "support_votes" },
      
      { "Push": 65.0 },
      { "Store": "against_votes" },
      
      { "Load": "current_proposal" },
      { "Load": "support_votes" },
      { "Load": "against_votes" },
      { "Call": "process_votes" },
      
      { "Dup": null },
      { "Push": 0.0 },
      { "Eq": null },
      { "Push": 1.0 },
      { "Eq": null },
      { "Or": null },
      { "Not": null },
      { "If": {
        "condition": [],
        "then": [
          { "EmitEvent": {
            "category": "governance",
            "message": "CRITICAL ERROR: Invalid vote result"
          }}
        ],
        "else_": null
      }},
      
      { "Load": "current_proposal" },
      { "Push": 10.0 },
      { "Mul": null },
      { "Add": null },
      { "Store": "result" },
      
      { "Load": "current_proposal" },
      { "Push": 1.0 },
      { "Add": null },
      { "Store": "current_proposal" }
    ]
  }},
  
  { "Push": 1.0 },
  { "Push": 1.0 },
  { "Push": 1.0 },
  { "AssertEqualStack": { "depth": 3 }},
  
  { "EmitEvent": {
    "category": "governance",
    "message": "Governance simulation completed"
  }},
  
  { "DumpStack": null },
  { "DumpMemory": null }
]
--- FILE: ./Cargo.toml ---
[package]
name = "nano-cvm"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
regex = "1.10"
clap = { version = "4.4", features = ["derive"] }
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
once_cell = "1.19"
rustyline = "12.0"
colored = "2.1"

[features]
default = []
--- FILE: ./README.md ---
# Nano-CVM: Cooperative Virtual Machine

A secure, stack-based virtual machine in Rust for the Intercooperative Network (ICN), featuring governance-inspired operations, memory-isolated execution, and a custom DSL parser.

## Features

- **Stack-based architecture**: Simple and secure execution model
- **Memory isolation**: Each function call has isolated memory space
- **Custom DSL**: Human-readable text format for programs
- **JSON serialization**: Machine-readable format for program interchange
- **Governance-inspired opcodes**: Special operations for cooperative decision processes

## Opcodes

### Core Operations
- Basic arithmetic: `Add`, `Sub`, `Mul`, `Div`, `Mod`
- Stack manipulation: `Push`, `Pop`, `Dup`, `Swap`, `Over`
- Memory: `Store`, `Load`
- Control flow: `If`, `Loop`, `While`, `Return`
- Functions: `Def`, `Call`

### Governance-Inspired Operations
- **Match**: Pattern-style branching for multi-way decisions
- **Break** and **Continue**: Fine-grained loop control
- **EmitEvent**: Trigger governance logs with categorized messages
- **AssertEqualStack**: Validate consensus/coordination by ensuring stack uniformity

## Usage

### Installation

```bash
cargo build --release
```

### Running Programs

The VM supports both the DSL text format and JSON serialized programs:

```bash
# Run a DSL program
./target/release/nano-cvm --program program.dsl

# Run a JSON program
./target/release/nano-cvm --program program.json

# Verbose output
./target/release/nano-cvm --program program.dsl --verbose
```

## DSL Syntax

```
# Define a function
def function_name(param1, param2):
    # Function body
    load param1
    load param2
    add
    return

# Invoke Match operation
match:
    value:
        # Instructions that leave a value on the stack
        push 1
        push 2
        add
    case 3:
        # Execute if value is 3
        push 30
    case 4:
        # Execute if value is 4
        push 40
    default:
        # Execute if no case matches
        push 999

# Break and Continue
while:
    push 1  # Infinite loop
    if:
        # Condition to break
        break
    if:
        # Condition to skip to next iteration
        continue

# Emit governance events
emitevent "category" "message"

# Validate stack consensus
push 42
push 42
push 42
assertequalstack 3  # Verify last 3 values are equal
```

## Security Features

- No `unsafe` Rust code
- Memory isolation between function calls
- Comprehensive stack underflow checks
- Detailed error messages
- Limited recursion depth protection

## Example

See `program.dsl` and `program.json` for example programs demonstrating the governance-inspired opcodes.

## License

MIT License 